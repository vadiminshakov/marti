// Code generated by mockery v2.20.0. DO NOT EDIT.

package trader

import (
	"context"

	decimal "github.com/shopspring/decimal"

	mock "github.com/stretchr/testify/mock"
)

// Trader is an autogenerated mock type for the Trader interface
// located under mocks/trader. It is 100 % compatible with the previous
// internal/services/trader/mock implementation.
//
// NOTE: the file was moved from internal/services/trader/mock to
// mocks/trader to keep all mocks in a single root-level folder.
type Trader struct {
	mock.Mock
}

// Buy provides a mock function with given fields: ctx, amount, clientOrderID
func (_m *Trader) Buy(ctx context.Context, amount decimal.Decimal, clientOrderID string) error {
	ret := _m.Called(ctx, amount, clientOrderID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, decimal.Decimal, string) error); ok {
		r0 = rf(ctx, amount, clientOrderID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Sell provides a mock function with given fields: ctx, amount, clientOrderID
func (_m *Trader) Sell(ctx context.Context, amount decimal.Decimal, clientOrderID string) error {
	ret := _m.Called(ctx, amount, clientOrderID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, decimal.Decimal, string) error); ok {
		r0 = rf(ctx, amount, clientOrderID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OrderExecuted provides a mock function with given fields: ctx, clientOrderID
func (_m *Trader) OrderExecuted(ctx context.Context, clientOrderID string) (bool, decimal.Decimal, error) {
	ret := _m.Called(ctx, clientOrderID)

	var r0 bool
	var r1 decimal.Decimal
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, decimal.Decimal, error)); ok {
		return rf(ctx, clientOrderID)
	}
	if len(ret) > 0 {
		if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
			r0 = rf(ctx, clientOrderID)
		} else {
			r0 = ret.Bool(0)
		}
	}
	if len(ret) > 1 {
		if rf, ok := ret.Get(1).(func(context.Context, string) decimal.Decimal); ok {
			r1 = rf(ctx, clientOrderID)
		} else {
			if ret.Get(1) != nil {
				r1 = ret.Get(1).(decimal.Decimal)
			}
		}
	}
	if len(ret) > 2 {
		if rf, ok := ret.Get(2).(func(context.Context, string) error); ok {
			r2 = rf(ctx, clientOrderID)
		} else {
			r2 = ret.Error(2)
		}
	}

	return r0, r1, r2
}

// GetBalance provides a mock function with given fields: ctx, currency
func (_m *Trader) GetBalance(ctx context.Context, currency string) (decimal.Decimal, error) {
	ret := _m.Called(ctx, currency)

	var r0 decimal.Decimal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (decimal.Decimal, error)); ok {
		return rf(ctx, currency)
	}
	if len(ret) > 0 {
		if rf, ok := ret.Get(0).(func(context.Context, string) decimal.Decimal); ok {
			r0 = rf(ctx, currency)
		} else {
			if ret.Get(0) != nil {
				r0 = ret.Get(0).(decimal.Decimal)
			}
		}
	}
	if len(ret) > 1 {
		if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
			r1 = rf(ctx, currency)
		} else {
			r1 = ret.Error(1)
		}
	}

	return r0, r1
}

type mockConstructorTestingTNewTrader interface {
	mock.TestingT
	Cleanup(func())
}

// NewTrader creates a new instance of Trader. It also registers a testing
// interface on the mock and a cleanup function to assert the mocks expectations.
func NewTrader(t mockConstructorTestingTNewTrader) *Trader {
	mockObj := &Trader{}
	mockObj.Mock.Test(t)

	t.Cleanup(func() { mockObj.AssertExpectations(t) })

	return mockObj
}
